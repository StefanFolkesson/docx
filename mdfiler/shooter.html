<!doctype html>
<html lang="sv">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Space Shooter – OOP/JS</title>
<style>
  html, body { margin:0; padding:0; background:#0b0f17; color:#cfe6ff; font-family:system-ui,Segoe UI,Arial; }
  #hud { position:fixed; left:12px; top:10px; font-size:14px; }
  canvas { display:block; margin:0 auto; background:radial-gradient(ellipse at center, #0b0f17 0%, #060913 70%, #04060d 100%); }
  .muted { opacity:.8 }
</style>
</head>
<body>
<div id="hud">
  <div>Poäng: <span id="score">0</span> &nbsp;|&nbsp; Liv: <span id="lives">3</span></div>
  <div class="muted">Styrning: ←/→ rotera, ↑ thrust, SPACE skjuta, R starta om</div>
</div>
<canvas id="game" width="900" height="640"></canvas>

<script>
// ---------- Verktyg ----------
const randRange = (a,b)=>a+Math.random()*(b-a);
const randSign = ()=> (Math.random()<.5?-1:1);
const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));

// ---------- Bas-klasser ----------
class SpelObjekt {
  constructor({x=0,y=0,r=10,alive=true}={}) {
    this.x=x; this.y=y; this.r=r; this.alive=alive; // r = “radius” för cirkelkollisioner
  }
  rect(){ return {x:this.x, y:this.y, r:this.r}; }
  // Enkel cirkel-kollision (passar skott/asteroider/skepp i den här stilen)
  krockarMed(o){
    const dx=this.x-o.x, dy=this.y-o.y;
    return (dx*dx + dy*dy) <= (this.r+o.r)*(this.r+o.r);
  }
  uppdatera(dt, world){}
  rita(ctx){}
}

class RorligtObjekt extends SpelObjekt {
  constructor(opts={}) {
    super(opts);
    this.vx=opts.vx??0; this.vy=opts.vy??0;
    this.ax=opts.ax??0; this.ay=opts.ay??0;
    this.rot=opts.rot??0;       // rotation i radianer
    this.vrot=opts.vrot??0;     // rotationshastighet
    this.friction=opts.friction??0.995;
    this.maxSpeed=opts.maxSpeed??600;
    this.wrap=true;             // “knyta ihop” kanter
  }
  uppdatera(dt, world){
    // Enkel rörelse/fysik
    this.vx += this.ax*dt; this.vy += this.ay*dt;
    this.vx *= this.friction; this.vy *= this.friction;
    // begränsa maxfart
    const sp = Math.hypot(this.vx,this.vy);
    if (sp > this.maxSpeed) { const s=this.maxSpeed/sp; this.vx*=s; this.vy*=s; }

    this.x += this.vx*dt; this.y += this.vy*dt;
    this.rot += this.vrot*dt;

    // Skärm-wrap
    if (this.wrap) {
      if (this.x < 0) this.x += world.W; else if (this.x > world.W) this.x -= world.W;
      if (this.y < 0) this.y += world.H; else if (this.y > world.H) this.y -= world.H;
    }
  }
}

// ---------- Skott ----------
class Skott extends RorligtObjekt {
  constructor({x,y,rot,speed=700,ttl=1.2}){
    const vx = Math.cos(rot)*speed;
    const vy = Math.sin(rot)*speed;
    super({x,y,vx,vy,rot, friction:1, r:3, maxSpeed:speed,});
    this.ttl = ttl; // “time to live”
    this.wrap=false; // skott försvinner utanför skärm
  }
  uppdatera(dt, world){
    super.uppdatera(dt, world);
    this.ttl -= dt;
    if (this.ttl <= 0) this.alive = false;
    if (this.x<0||this.x>world.W||this.y<0||this.y>world.H) this.alive=false;
  }
  rita(ctx){
    ctx.save();
    ctx.translate(this.x,this.y);
    ctx.beginPath();
    ctx.arc(0,0,this.r,0,Math.PI*2);
    ctx.fillStyle="#cfe6ff";
    ctx.fill();
    ctx.restore();
  }
}

// ---------- Asteroid ----------
/*
  storlek: 3 (stor), 2 (mellan), 1 (liten)
  Ritar klumpig polygon för att få “asteroid-känsla”.
*/
class Asteroid extends RorligtObjekt {
  constructor({x,y,storlek=3}){
    const baseR = storlek===3? 48 : (storlek===2? 28 : 16);
    const vink = Math.random()*Math.PI*2;
    const speed = randRange(40, 120);
    super({
      x,y, r: baseR,
      vx: Math.cos(vink)*speed*randSign(),
      vy: Math.sin(vink)*speed*randSign(),
      friction: 1, maxSpeed: 200,
      vrot: randRange(-1,1)
    });
    this.storlek = storlek;
    // För ritytan: generera “taggig” form
    this.points = this._genPoints();
  }
  _genPoints(){
    const count = 10 + Math.floor(Math.random()*6);
    const pts = [];
    for (let i=0;i<count;i++){
      const a = i/count*Math.PI*2;
      const rad = this.r * randRange(0.7, 1.15);
      pts.push({a, rad});
    }
    return pts;
  }
  split(){
    // träffad: skapa 3 mindre om möjligt, annars inget
    if (this.storlek>1){
      const list=[];
      for (let i=0;i<3;i++){
        const a = Math.random()*Math.PI*2;
        const off = randRange(6,12);
        list.push(new Asteroid({
          x: this.x + Math.cos(a)*off,
          y: this.y + Math.sin(a)*off,
          storlek: this.storlek-1
        }));
      }
      return list;
    }
    return [];
  }
  rita(ctx){
    ctx.save();
    ctx.translate(this.x,this.y);
    ctx.rotate(this.rot);
    ctx.strokeStyle="#93b7ff";
    ctx.lineWidth=2;
    ctx.beginPath();
    for (let i=0;i<this.points.length;i++){
      const p=this.points[i];
      const nx = Math.cos(p.a)*p.rad;
      const ny = Math.sin(p.a)*p.rad;
      if (i===0) ctx.moveTo(nx,ny); else ctx.lineTo(nx,ny);
    }
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }
}

// ---------- Spelare ----------
class Spelare extends RorligtObjekt {
  constructor({x,y}){
    super({x,y,r:15, friction:.995, maxSpeed:350});
    this.cooldown=0;     // skott-cd
    this.fireRate=0.18;  // sekunder mellan skott
    this.thrustPower=380;
    this.turnSpeed=3.2;  // rad/s
    this.iFrames=1.2;    // odödlig i start/respawn
  }
  hanteraInput(input, dt){
    if (input.vanster) this.vrot = -this.turnSpeed;
    else if (input.hoger) this.vrot = this.turnSpeed;
    else this.vrot = 0;

    if (input.upp){
      // thrust i nosens riktning
      this.ax = Math.cos(this.rot)*this.thrustPower;
      this.ay = Math.sin(this.rot)*this.thrustPower;
    } else {
      this.ax = 0; this.ay = 0;
    }
  }
  skjut(world){
    if (this.cooldown>0) return;
    this.cooldown = this.fireRate;
    const noseX = this.x + Math.cos(this.rot)*this.r*1.2;
    const noseY = this.y + Math.sin(this.rot)*this.r*1.2;
    world.skott.push(new Skott({x:noseX, y:noseY, rot:this.rot}));
  }
  uppdatera(dt, world){
    super.uppdatera(dt, world);
    this.cooldown -= dt;
    this.iFrames = Math.max(0, this.iFrames - dt);
  }
  rita(ctx){
    ctx.save();
    ctx.translate(this.x,this.y);
    ctx.rotate(this.rot);
    ctx.strokeStyle = this.iFrames>0 ? "#8fffd3" : "#eaf1ff";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(18,0);     // nos
    ctx.lineTo(-14,10);
    ctx.lineTo(-8,0);
    ctx.lineTo(-14,-10);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }
}

// ---------- Fiende (valfri) ----------
class Fiende extends RorligtObjekt {
  constructor({x,y}){
    super({x,y,r:16, friction:.995, maxSpeed:280});
    this.turnSpeed=2.4;
    this.thrustPower=260;
    this.cooldown=randRange(.6,1.4);
    this.fireRate=randRange(.8,1.6);
  }
  uppdatera(dt, world){
    // enkel AI: rotera mot spelaren + thrust
    const t=world.spelare;
    const dx=t.x-this.x, dy=t.y-this.y;
    const want = Math.atan2(dy,dx);
    // hitta kortaste vinkel
    let diff = ((want - this.rot + Math.PI*3)%(Math.PI*2))-Math.PI;
    this.vrot = clamp(diff, -this.turnSpeed, this.turnSpeed);
    // gas om hyfsat riktad
    if (Math.abs(diff)<0.4){ this.ax=Math.cos(this.rot)*this.thrustPower; this.ay=Math.sin(this.rot)*this.thrustPower; }
    else { this.ax=0; this.ay=0; }

    // skjut ibland
    this.cooldown -= dt;
    if (this.cooldown<=0){
      this.cooldown = this.fireRate;
      const noseX = this.x + Math.cos(this.rot)*this.r*1.2;
      const noseY = this.y + Math.sin(this.rot)*this.r*1.2;
      world.fiendeSkott.push(new Skott({x:noseX, y:noseY, rot:this.rot, speed:520, ttl:1.8}));
    }

    super.uppdatera(dt, world);
  }
  rita(ctx){
    ctx.save();
    ctx.translate(this.x,this.y);
    ctx.rotate(this.rot);
    ctx.strokeStyle="#ff9b9b";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(16,0);
    ctx.lineTo(-12,12);
    ctx.lineTo(-6,0);
    ctx.lineTo(-12,-12);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }
}

// ---------- Värld / Spelsetup ----------
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const HUD = {
  score: document.getElementById("score"),
  lives: document.getElementById("lives")
};
const WORLD = {
  W: canvas.width, H: canvas.height,
  spelare: null,
  asteroider: [],
  skott: [],
  fiender: [],
  fiendeSkott: [],
  score: 0,
  lives: 3,
  running: true
};

// ---------- Input ----------
const input = { upp:false, vanster:false, hoger:false, space:false };
window.addEventListener("keydown", (e)=>{
  if (e.code==="ArrowUp") input.upp=true;
  if (e.code==="ArrowLeft") input.vanster=true;
  if (e.code==="ArrowRight") input.hoger=true;
  if (e.code==="Space"){ if (!input.space) WORLD.spelare?.skjut(WORLD); input.space=true; }
  if (e.code==="KeyR"){ if(!WORLD.running) startGame(); }
});
window.addEventListener("keyup", (e)=>{
  if (e.code==="ArrowUp") input.upp=false;
  if (e.code==="ArrowLeft") input.vanster=false;
  if (e.code==="ArrowRight") input.hoger=false;
  if (e.code==="Space") input.space=false;
});

// ---------- Spel-loop ----------
let last = performance.now();

function startGame(){
  WORLD.score=0; WORLD.lives=3; WORLD.running=true;
  WORLD.skott.length=0; WORLD.asteroider.length=0; WORLD.fiender.length=0; WORLD.fiendeSkott.length=0;

  WORLD.spelare = new Spelare({x: WORLD.W/2, y: WORLD.H/2});

  // Starta asteroider
  for (let i=0;i<6;i++){
    let x,y;
    // spawna inte för nära spelaren
    do {
      x=randRange(0,WORLD.W); y=randRange(0,WORLD.H);
    } while (Math.hypot(x-WORLD.spelare.x,y-WORLD.spelare.y)<160);
    WORLD.asteroider.push(new Asteroid({x,y,storlek:3}));
  }

  // En liten fiende för krydda
  WORLD.fiender.push(new Fiende({x:randRange(40,WORLD.W-40), y:randRange(40,WORLD.H-40)}));

  HUD.score.textContent = WORLD.score;
  HUD.lives.textContent = WORLD.lives;
}

function gameOver(){
  WORLD.running=false;
  ctx.save();
  ctx.fillStyle="#d9eeff";
  ctx.font="24px system-ui, Arial";
  ctx.textAlign="center";
  ctx.fillText("Game Over – tryck R för att starta om", WORLD.W/2, WORLD.H/2);
  ctx.restore();
}

function update(dt){
  if (!WORLD.running) return;

  WORLD.spelare.hanteraInput(input, dt);

  // Uppdatera objekt
  WORLD.spelare.uppdatera(dt, WORLD);
  WORLD.skott.forEach(s=>s.uppdatera(dt, WORLD));
  WORLD.fiendeSkott.forEach(s=>s.uppdatera(dt, WORLD));
  WORLD.asteroider.forEach(a=>a.uppdatera(dt, WORLD));
  WORLD.fiender.forEach(f=>f.uppdatera(dt, WORLD));

  // --- Kollisioner ---
  // Skott vs Asteroider
  for (const s of WORLD.skott){
    if (!s.alive) continue;
    for (const a of WORLD.asteroider){
      if (!a.alive) continue;
      if (s.krockarMed(a)){
        s.alive=false; a.alive=false;
        WORLD.score += (a.storlek===3? 20 : a.storlek===2? 50 : 100);
        // split
        const nya = a.split();
        WORLD.asteroider.push(...nya);
        break;
      }
    }
  }

  // Fiendeskott vs Spelare
  for (const s of WORLD.fiendeSkott){
    if (!s.alive) continue;
    if (WORLD.spelare.krockarMed(s) && WORLD.spelare.iFrames<=0){
      s.alive=false;
      forstraffaSpelare();
    }
  }

  // Spelare vs Asteroider
  if (WORLD.spelare.iFrames<=0){
    for (const a of WORLD.asteroider){
      if (a.alive && WORLD.spelare.krockarMed(a)){
        forstraffaSpelare();
        break;
      }
    }
  }

  // Fiendeskott/Skott rensa döda, Asteroider/Fiender rensa
  WORLD.skott = WORLD.skott.filter(o=>o.alive);
  WORLD.fiendeSkott = WORLD.fiendeSkott.filter(o=>o.alive);
  WORLD.asteroider = WORLD.asteroider.filter(o=>o.alive);
  WORLD.fiender = WORLD.fiender.filter(o=>o.alive);

  // Se till att det finns asteroider (nästa våg)
  if (WORLD.asteroider.length===0){
    const n = 4 + Math.floor(Math.random()*3);
    for (let i=0;i<n;i++){
      WORLD.asteroider.push(new Asteroid({x:randRange(0,WORLD.W), y:randRange(0,WORLD.H), storlek:3}));
    }
    // spawna ibland en fiende
    if (Math.random()<0.6) WORLD.fiender.push(new Fiende({x:randRange(40,WORLD.W-40), y:randRange(40,WORLD.H-40)}));
  }

  HUD.score.textContent = WORLD.score;
}

function forstraffaSpelare(){
  WORLD.lives--;
  HUD.lives.textContent = WORLD.lives;
  if (WORLD.lives<=0){ gameOver(); return; }
  // respawn i mitten + odödlig kort stund
  WORLD.spelare.x = WORLD.W/2; WORLD.spelare.y = WORLD.H/2;
  WORLD.spelare.vx=0; WORLD.spelare.vy=0; WORLD.spelare.rot=-Math.PI/2;
  WORLD.spelare.iFrames=1.5;
}

function render(){
  // Stjärnhimmel
  ctx.clearRect(0,0,WORLD.W,WORLD.H);
  // (enkel bakgrunds-stjärn-dither)
  for (let i=0;i<140;i++){
    const x=(i*57%WORLD.W), y=(i*131%WORLD.H), s=(i%5?1:2);
    ctx.fillStyle = i%7? "#1b2840" : "#24365b";
    ctx.fillRect(x,y,s,s);
  }

  // Rita entiteter
  WORLD.asteroider.forEach(a=>a.rita(ctx));
  WORLD.fiender.forEach(f=>f.rita(ctx));
  WORLD.fiendeSkott.forEach(s=>s.rita(ctx));
  WORLD.skott.forEach(s=>s.rita(ctx));
  WORLD.spelare.rita(ctx);

  // Blinka runt spelaren vid iFrames
  if (WORLD.spelare.iFrames>0 && (performance.now()/120|0)%2===0){
    ctx.save();
    ctx.strokeStyle="#61ffd5";
    ctx.globalAlpha=.5;
    ctx.beginPath();
    ctx.arc(WORLD.spelare.x, WORLD.spelare.y, WORLD.spelare.r*1.6, 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();
  }

  if (!WORLD.running){
    ctx.save();
    ctx.fillStyle="#d9eeff";
    ctx.font="28px system-ui, Arial";
    ctx.textAlign="center";
    ctx.fillText("Game Over – tryck R för att starta om", WORLD.W/2, WORLD.H/2);
    ctx.restore();
  }
}

function loop(now){
  const dt = Math.min(0.033, (now-last)/1000); // cap 30ms
  last = now;
  update(dt);
  render();
  requestAnimationFrame(loop);
}

// Start!
startGame();
requestAnimationFrame(loop);
</script>
</body>
</html>
